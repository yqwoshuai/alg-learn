# 树

## 第104题

[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/description/)

```javascript
// function TreeNode(val, left, right) {
//   this.val = (val===undefined ? 0 : val)
//   this.left = (left===undefined ? null : left)
//   this.right = (right===undefined ? null : right)
// }
var maxDepth = function (root) {
  // 空节点返回0
  if (root === null) return 0;
  // 递归查询左右叶子节点的最大值 每层递归 + 1
  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
};
```

## 第110题

[平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

```javascript
var isBalanced = function (root) {
  let result = true;

  function maxDepth(root) {
    if (root === null) return 0;
    // 递归查询左右子节点的高度
    let l = maxDepth(root.left);
    let r = maxDepth(root.right);
    // 不平衡时修改结果
    if (Math.abs(l - r) > 1) {
      result = false;
    }
    return Math.max(l, r) + 1;
  }
  maxDepth(root);

  return result;
};
```

## 第543题

[二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

```javascript
var diameterOfBinaryTree = function (root) {
  let max = 0;

  function maxLength(root) {
    if (root === null) {
      return 0;
    }
    let l = maxLength(root.left);
    let r = maxLength(root.right);
    // 修改当前最短路径的最大值
    max = Math.max(max, l + r);
    // 返回左右子节点的最大值
    return Math.max(l, r) + 1;
  }
  maxLength(root);

  return max
};
```

## 第226题

[翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/description/)

```javascript
var invertTree = function (root) {
  if (root === null) return null;

  // 保存一下左侧的引用，因为交换之后左侧的引用会被换掉
  let prevLeft = root.left;
  // 递归交换
  root.left = invertTree(root.right);
  root.right = invertTree(prevLeft);

  return root
};
```

## 第617题

[合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/description/)

```javascript
var mergeTrees = function (root1, root2) {
  if (root1 == null && root2 == null) return null;
  if (root1 == null) return root2;
  if (root2 == null) return root1;

  // 构建一颗新树，用来保存合并后的树
  const root = new TreeNode(root1.val + root2.val);
  // 递归合并左右子节点
  root.left = mergeTrees(root1.left, root2.left);
  root.right = mergeTrees(root1.right, root2.right);
  return root;
};
```
