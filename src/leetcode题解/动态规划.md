# 动态规划

## 斐波那契数列

### 第70题

[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```javascript
var climbStairs = function (n) {
  // 爬到第n级台阶的方法数为爬到第n-1与第n-2级台阶方法数的和
  // 即 f(n) = f(n-1) + f(n-2)
  let pre = 0,
    next = 0,
    add = 1;
  // 利用滚动数组，不断向前赋值，数组前两项和为第三项，进行累加
  for (let i = 0; i < n; i++) {
    pre = next;
    next = add;
    add = next + pre;
  }
  return add;
};
```

### 第198题

[打家劫舍](https://leetcode-cn.com/problems/house-robber/description/)

```javascript
var rob = function (nums) {
  // 偷了第n间房屋，就不能偷第n-1间房屋，但是能偷第n-2间房屋 
  // 所以前n间房屋的总和为 前n-2间房屋总和 加上 第n间房屋 与 前n-1间房屋总和 之间的最大值
  //  f(n) = max( f(n-2) + nums[n] , f(n-1) )
  let pre = 0, // f(n-2)
    next = 0, // f(n-1)
    add = 0; // f(n)
  // 利用滚动数组
  for (let i = 0; i < nums.length; i++) {
    add = Math.max(pre + nums[i], next);
    // 数组向前滚动，后一项替换前一项
    pre = next;
    next = add;
  }
  return next;
};
```

### 第213题

[打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

```javascript
var findMax = function (nums) {
  let pre = 0,
    next = 0,
    add = 0;
  // 利用滚动数组累加
  for (let i = 0; i < nums.length; i++) {
    add = Math.max(pre + nums[i], next);
    pre = next;
    next = add;
  }
  return next;
};

var rob = function (nums) {
  // 处理特殊情况
  if(nums.length === 0) return 0;
  if(nums.length === 1) return nums[0];
  // 环状表示第一个和最后一个房子之间一定是一个偷一个不偷
  // 则有两种情况，一种是偷第一个房子，一种是偷最后一个房子
  // 只要求解两种结果取最大值即可
  // 偷第一家的情况
  let getFirst = findMax(nums.slice(0, nums.length - 1));
  // 不偷第一家的情况
  let getLast = findMax(nums.slice(1));
  return Math.max(getFirst, getLast);
};
```

### 第64题

[最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

```javascript
var minPathSum = function (grid) {
  // 第一行与第一列的路径是固定的，即二维数组中某一下标为0时，总路径是固定的
  // 第一行某格的总路程为 f( grid[0][i] ) = f( grid[0][i - 1] ) + grid[0][i]
  // 第一列某格的总路程为 f( grid[i][0] ) = f( grid[i - 1][0] ) + grid[i][0]
  // 除去第一行与第一列的格子，其他格子的总路径为其 上方格子的总路径 与 左侧格子的总路径 之间的最小值 加上其本身
  // 即  f( grid[i][j] ) = min( f( grid[i - 1][j] ), f( grid[i][j - 1] ) ) + grid[i][j]

  // 定义二维数组储存到达每个单元格的最短路径
  const arr = [[grid[0][0]]];
  // 第一行每个单元格的总路程
  for (let i = 1; i < grid[0].length; i++) {
    let add = arr[0][i - 1] + grid[0][i];
    arr[0].push(add);
  }
  // 第一列每个单元格的总路程
  for (let j = 1; j < grid.length; j++) {
    let add = arr[j - 1][0] + grid[j][0];
    arr.push([add]);
  }
  // 其他单元格的总路程
  // 遍历每一行
  for (let x = 1; x < grid.length; x++) {
    // 遍历当前行的每一列，即当前行的每个单元格
    for (let y = 1; y < grid[x].length; y++) {
      let add = Math.min(arr[x - 1][y], arr[x][y - 1]) + grid[x][y];
      arr[x].push(add)
    }
  }
  // 最后一个单元格为最短路径
  return arr[arr.length - 1][arr[arr.length - 1].length - 1];
};
```

### 第62题

[不同路径](https://leetcode-cn.com/problems/unique-paths/description/)

```javascript
var uniquePaths = function (m, n) {
  let arr = [];
  // 到达第一行和第一列每个单元格的方法都只有一种，所以第一行第一列全为1
  // 到达第一列每个单元格的方法数
  for (let i = 0; i < m; i++) {
    arr.push([1]);
  }
  // 到达第一行每个单元格的方法数
  arr[0] = Array(n).fill(1);
  // 到达其他单元格的方法数
  for (let x = 1; x < m; x++) {
    for (let y = 1; y < n; y++) {
      // 到达当前单元格的方法数为其 上方单元格 和 左侧单元格 的 和
      let add = arr[x - 1][y] + arr[x][y - 1];
      arr[x].push(add);
    }
  }
  // 返回最后一个元素
  return arr[m - 1][n - 1];
};
```

### 第303题

[区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/description/)

```javascript
var NumArray = function (nums) {
  // 使用一个数组储存前n项的和，后一项等于之前所有项的和加上当前项
  // f(n) = f(n - 1) + nums[n]
  const sums = [nums[0]];
  for (let i = 1; i < nums.length; i++) {
    let add = sums[i - 1] + nums[i];
    sums.push(add);
  }
  // 首项推入一个0，保证计算从0开始的值
  sums.unshift(0)
  this.sums = sums;
};

NumArray.prototype.sumRange = function (i, j) {
  // 因为已经使用数组储存前n项的和
  // 所以第i项 到 第j项 的和等于 sums数组中 第j+1项 减去 i项
  return this.sums[j + 1] - this.sums[i];
};
```
