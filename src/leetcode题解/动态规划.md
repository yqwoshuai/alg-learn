# 动态规划

## 第70题

[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```javascript
var climbStairs = function (n) {
  // 爬到第n级台阶的方法数为爬到第n-1与第n-2级台阶方法数的和
  // 即 f(n) = f(n-1) + f(n-2)
  let pre = 0,
    next = 0,
    add = 1;
  // 利用滚动数组，不断向前赋值，数组前两项和为第三项，进行累加
  for (let i = 0; i < n; i++) {
    pre = next;
    next = add;
    add = next + pre;
  }
  return add;
};
```

## 第198题

[打家劫舍](https://leetcode-cn.com/problems/house-robber/description/)

```javascript
var rob = function (nums) {
  // 偷了第n间房屋，就不能偷第n-1间房屋，但是能偷第n-2间房屋 
  // 所以前n间房屋的总和为 前n-2间房屋总和 加上 第n间房屋 与 前n-1间房屋总和 之间的最大值
  //  f(n) = max( f(n-2) + nums[n] , f(n-1) )
  let pre = 0, // f(n-2)
    next = 0, // f(n-1)
    add = 0; // f(n)
  // 利用滚动数组
  for (let i = 0; i < nums.length; i++) {
    add = Math.max(pre + nums[i], next);
    // 数组向前滚动，后一项替换前一项
    pre = next;
    next = add;
  }
  return next;
};
```

## 第213题

[打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

```javascript
var findMax = function (nums) {
  let pre = 0,
    next = 0,
    add = 0;
  // 利用滚动数组累加
  for (let i = 0; i < nums.length; i++) {
    add = Math.max(pre + nums[i], next);
    pre = next;
    next = add;
  }
  return next;
};

var rob = function (nums) {
  // 处理特殊情况
  if(nums.length === 0) return 0;
  if(nums.length === 1) return nums[0];
  // 环状表示第一个和最后一个房子之间一定是一个偷一个不偷
  // 则有两种情况，一种是偷第一个房子，一种是偷最后一个房子
  // 只要求解两种结果取最大值即可
  // 偷第一家的情况
  let getFirst = findMax(nums.slice(0, nums.length - 1));
  // 不偷第一家的情况
  let getLast = findMax(nums.slice(1));
  return Math.max(getFirst, getLast);
};
```

## 第64题

[最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

```javascript
var minPathSum = function (grid) {
  // 第一行与第一列的路径是固定的，即二维数组中某一下标为0时，总路径是固定的
  // 第一行某格的总路程为 f( grid[0][i] ) = f( grid[0][i - 1] ) + grid[0][i]
  // 第一列某格的总路程为 f( grid[i][0] ) = f( grid[i - 1][0] ) + grid[i][0]
  // 除去第一行与第一列的格子，其他格子的总路径为其 上方格子的总路径 与 左侧格子的总路径 之间的最小值 加上其本身
  // 即  f( grid[i][j] ) = min( f( grid[i - 1][j] ), f( grid[i][j - 1] ) ) + grid[i][j]

  // 定义二维数组储存到达每个单元格的最短路径
  const arr = [[grid[0][0]]];
  // 第一行每个单元格的总路程
  for (let i = 1; i < grid[0].length; i++) {
    let add = arr[0][i - 1] + grid[0][i];
    arr[0].push(add);
  }
  // 第一列每个单元格的总路程
  for (let j = 1; j < grid.length; j++) {
    let add = arr[j - 1][0] + grid[j][0];
    arr.push([add]);
  }
  // 其他单元格的总路程
  // 遍历每一行
  for (let x = 1; x < grid.length; x++) {
    // 遍历当前行的每一列，即当前行的每个单元格
    for (let y = 1; y < grid[x].length; y++) {
      let add = Math.min(arr[x - 1][y], arr[x][y - 1]) + grid[x][y];
      arr[x].push(add)
    }
  }
  // 最后一个单元格为最短路径
  return arr[arr.length - 1][arr[arr.length - 1].length - 1];
};
```

## 第62题

[不同路径](https://leetcode-cn.com/problems/unique-paths/description/)

```javascript
var uniquePaths = function (m, n) {
  let arr = [];
  // 到达第一行和第一列每个单元格的方法都只有一种，所以第一行第一列全为1
  // 到达第一列每个单元格的方法数
  for (let i = 0; i < m; i++) {
    arr.push([1]);
  }
  // 到达第一行每个单元格的方法数
  arr[0] = Array(n).fill(1);
  // 到达其他单元格的方法数
  for (let x = 1; x < m; x++) {
    for (let y = 1; y < n; y++) {
      // 到达当前单元格的方法数为其 上方单元格 和 左侧单元格 的 和
      let add = arr[x - 1][y] + arr[x][y - 1];
      arr[x].push(add);
    }
  }
  // 返回最后一个元素
  return arr[m - 1][n - 1];
};
```

## 第303题

[区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/description/)

```javascript
var NumArray = function (nums) {
  // 使用一个数组储存前n项的和，后一项等于之前所有项的和加上当前项
  // f(n) = f(n - 1) + nums[n]
  const sums = [nums[0]];
  for (let i = 1; i < nums.length; i++) {
    let add = sums[i - 1] + nums[i];
    sums.push(add);
  }
  // 首项推入一个0，保证计算从0开始的值
  sums.unshift(0)
  this.sums = sums;
};

NumArray.prototype.sumRange = function (i, j) {
  // 因为已经使用数组储存前n项的和
  // 所以第i项 到 第j项 的和等于 sums数组中 第j+1项 减去 i项
  return this.sums[j + 1] - this.sums[i];
};
```

## 第300题

[最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```javascript
var lengthOfLIS = function (nums) {
  // 记录每一项能够组成的最长增长序列的长度
  // 当前项能够组成最长增长序列的长度为 它之前的项能够组成最长增长序列的长度最大值 加上 当前项，即 + 1
  // f(i) = max( f(j) ) + 1
  const arr = [1];
  let max = 1;
  // 遍历数组，每一项都与它之前的所有项进行对比，遇到小于当前项的，说明能和当前项组成增长序列
  for (let i = 1; i < nums.length; i++) {
    // 当前项自己单独成列的长度为1
    arr[i] = 1;
    // 遍历当前项之前所有的项
    for (let j = 0; j < i; j++) {
      // 当前项大于之前的某一项时
      if (nums[i] > nums[j]) {
        // 将当前项修改为 当前项 与 某一项拼接当前项后 之间的长度最大值
        arr[i] = Math.max(arr[i], arr[j] + 1);
        // 经过这轮遍历后当前项就储存了它能够组成最长增长序列的长度
      }
    }
    // 替换最大值
    max = Math.max(max, arr[i]);
  }
  return max;
};
```

## 第1143题

[最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

```javascript
var longestCommonSubsequence = function (text1, text2) {
  // 定义 2X2的表 即二维数组来储存最长公共子序列，表的横轴表示text1元素，纵轴表示text2元素
  // 相交的点为 f( arr[i][j] )，表示text1第i项，和text2第j项，两者能够找到的最长公共子序列
  // 第一行表示text1为空数组，即第一行公共子序列全为0，第一列同理，即 f( arr[i][0]) 和 f( arr[0][j] )都为0
  const arr = [[0]];
  // 填充第一行和第一列，注意需要空出arr[0][0]来表示初始值
  for (let x = 0; x < text1.length; x++) {
    arr.push([0]);
  }
  arr[0] = Array(text2.length + 1).fill(0);
  // 遍历填充二维数组，注意之前空出了 arr[0][0] 所以遍历结束位置是 length + 1
  for (let i = 1; i < text1.length + 1; i++) {
    for (let j = 1; j < text2.length + 1; j++) {
      // 分两种情况，即 text1[i - 1] 与 text2[j - 1] 相同和不相同两种情况
      if (text1[i - 1] === text2[j - 1]) {
        // text1[i - 1] 与 text2[j - 1] 相同时，表示此时找到了相同字符，可以让最长公共子序列 + 1
        // 即 arr[i][j] = arr[i - 1][j - 1] + 1
        arr[i][j] = arr[i - 1][j - 1] + 1;
      } else {
        // text1[i - 1] 与 text2[j - 1] 不相同，表示此时的字符不相同，当前值应取 arr[i][j - 1] 和 arr[i - 1][j]两者之间的最大值
        // 即 arr[i][j] = max( arr[i][j - 1] , arr[i - 1][j] )
        arr[i][j] = Math.max(arr[i][j - 1], arr[i - 1][j]);
      }
    }
  }
  // 最终 arr[i][j] 表示的就是最长公共子序列，因为arr多了一个初始元素arr[0][0]，所以最后一个元素是length,不是length - 1
  return arr[text1.length][text2.length];
};
```
