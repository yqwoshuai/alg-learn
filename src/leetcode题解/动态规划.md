# 动态规划

## 第70题

[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```javascript
var climbStairs = function (n) {
  // 爬到第n级台阶的方法数为爬到第n-1与第n-2级台阶方法数的和
  // 即 f(n) = f(n-1) + f(n-2)
  let pre = 0,
    next = 0,
    add = 1;
  // 利用滚动数组，不断向前赋值，数组前两项和为第三项，进行累加
  for (let i = 0; i < n; i++) {
    pre = next;
    next = add;
    add = next + pre;
  }
  return add;
};
```

## 第198题

[打家劫舍](https://leetcode-cn.com/problems/house-robber/description/)

```javascript
var rob = function (nums) {
  // 偷了第n间房屋，就不能偷第n-1间房屋，但是能偷第n-2间房屋 
  // 所以前n间房屋的总和为 前n-2间房屋总和 加上 第n间房屋 与 前n-1间房屋总和 之间的最大值
  //  f(n) = max( f(n-2) + nums[n] , f(n-1) )
  let pre = 0, // f(n-2)
    next = 0, // f(n-1)
    add = 0; // f(n)
  // 利用滚动数组
  for (let i = 0; i < nums.length; i++) {
    add = Math.max(pre + nums[i], next);
    // 数组向前滚动，后一项替换前一项
    pre = next;
    next = add;
  }
  return next;
};
```

## 第213题

[打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

```javascript
var findMax = function (nums) {
  let pre = 0,
    next = 0,
    add = 0;
  // 利用滚动数组累加
  for (let i = 0; i < nums.length; i++) {
    add = Math.max(pre + nums[i], next);
    pre = next;
    next = add;
  }
  return next;
};

var rob = function (nums) {
  // 处理特殊情况
  if(nums.length === 0) return 0;
  if(nums.length === 1) return nums[0];
  // 环状表示第一个和最后一个房子之间一定是一个偷一个不偷
  // 则有两种情况，一种是偷第一个房子，一种是偷最后一个房子
  // 只要求解两种结果取最大值即可
  // 偷第一家的情况
  let getFirst = findMax(nums.slice(0, nums.length - 1));
  // 不偷第一家的情况
  let getLast = findMax(nums.slice(1));
  return Math.max(getFirst, getLast);
};
```

## 第64题

[最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

```javascript
var minPathSum = function (grid) {
  // 第一行与第一列的路径是固定的，即二维数组中某一下标为0时，总路径是固定的
  // 第一行某格的总路程为 f( grid[0][i] ) = f( grid[0][i - 1] ) + grid[0][i]
  // 第一列某格的总路程为 f( grid[i][0] ) = f( grid[i - 1][0] ) + grid[i][0]
  // 除去第一行与第一列的格子，其他格子的总路径为其 上方格子的总路径 与 左侧格子的总路径 之间的最小值 加上其本身
  // 即  f( grid[i][j] ) = min( f( grid[i - 1][j] ), f( grid[i][j - 1] ) ) + grid[i][j]

  // 定义二维数组储存到达每个单元格的最短路径
  const arr = [[grid[0][0]]];
  // 第一行每个单元格的总路程
  for (let i = 1; i < grid[0].length; i++) {
    let add = arr[0][i - 1] + grid[0][i];
    arr[0].push(add);
  }
  // 第一列每个单元格的总路程
  for (let j = 1; j < grid.length; j++) {
    let add = arr[j - 1][0] + grid[j][0];
    arr.push([add]);
  }
  // 其他单元格的总路程
  // 遍历每一行
  for (let x = 1; x < grid.length; x++) {
    // 遍历当前行的每一列，即当前行的每个单元格
    for (let y = 1; y < grid[x].length; y++) {
      let add = Math.min(arr[x - 1][y], arr[x][y - 1]) + grid[x][y];
      arr[x].push(add)
    }
  }
  // 最后一个单元格为最短路径
  return arr[arr.length - 1][arr[arr.length - 1].length - 1];
};
```

## 第62题

[不同路径](https://leetcode-cn.com/problems/unique-paths/description/)

```javascript
var uniquePaths = function (m, n) {
  let arr = [];
  // 到达第一行和第一列每个单元格的方法都只有一种，所以第一行第一列全为1
  // 到达第一列每个单元格的方法数
  for (let i = 0; i < m; i++) {
    arr.push([1]);
  }
  // 到达第一行每个单元格的方法数
  arr[0] = Array(n).fill(1);
  // 到达其他单元格的方法数
  for (let x = 1; x < m; x++) {
    for (let y = 1; y < n; y++) {
      // 到达当前单元格的方法数为其 上方单元格 和 左侧单元格 的 和
      let add = arr[x - 1][y] + arr[x][y - 1];
      arr[x].push(add);
    }
  }
  // 返回最后一个元素
  return arr[m - 1][n - 1];
};
```

## 第303题

[区域和检索 - 数组不可变](https://leetcode-cn.com/problems/range-sum-query-immutable/description/)

```javascript
var NumArray = function (nums) {
  // 使用一个数组储存前n项的和，后一项等于之前所有项的和加上当前项
  // f(n) = f(n - 1) + nums[n]
  const sums = [nums[0]];
  for (let i = 1; i < nums.length; i++) {
    let add = sums[i - 1] + nums[i];
    sums.push(add);
  }
  // 首项推入一个0，保证计算从0开始的值
  sums.unshift(0)
  this.sums = sums;
};

NumArray.prototype.sumRange = function (i, j) {
  // 因为已经使用数组储存前n项的和
  // 所以第i项 到 第j项 的和等于 sums数组中 第j+1项 减去 i项
  return this.sums[j + 1] - this.sums[i];
};
```

## 第300题

[最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```javascript
var lengthOfLIS = function (nums) {
  // 记录每一项能够组成的最长增长序列的长度
  // 当前项能够组成最长增长序列的长度为 它之前的项能够组成最长增长序列的长度最大值 加上 当前项，即 + 1
  // f(i) = max( f(j) ) + 1
  const arr = [1];
  let max = 1;
  // 遍历数组，每一项都与它之前的所有项进行对比，遇到小于当前项的，说明能和当前项组成增长序列
  for (let i = 1; i < nums.length; i++) {
    // 当前项自己单独成列的长度为1
    arr[i] = 1;
    // 遍历当前项之前所有的项
    for (let j = 0; j < i; j++) {
      // 当前项大于之前的某一项时
      if (nums[i] > nums[j]) {
        // 将当前项修改为 当前项 与 某一项拼接当前项后 之间的长度最大值
        arr[i] = Math.max(arr[i], arr[j] + 1);
        // 经过这轮遍历后当前项就储存了它能够组成最长增长序列的长度
      }
    }
    // 替换最大值
    max = Math.max(max, arr[i]);
  }
  return max;
};
```

## 第1143题

[最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

```javascript
var longestCommonSubsequence = function (text1, text2) {
  // 定义 2X2的表 即二维数组来储存最长公共子序列，表的横轴表示text1元素，纵轴表示text2元素
  // 相交的点为 f( arr[i][j] )，表示text1第i项，和text2第j项，两者能够找到的最长公共子序列
  // 第一行表示text1为空数组，即第一行公共子序列全为0，第一列同理，即 f( arr[i][0]) 和 f( arr[0][j] )都为0
  const arr = [[0]];
  // 填充第一行和第一列，注意需要空出arr[0][0]来表示初始值
  for (let x = 0; x < text1.length; x++) {
    arr.push([0]);
  }
  arr[0] = Array(text2.length + 1).fill(0);
  // 遍历填充二维数组，注意之前空出了 arr[0][0] 所以遍历结束位置是 length + 1
  for (let i = 1; i < text1.length + 1; i++) {
    for (let j = 1; j < text2.length + 1; j++) {
      // 分两种情况，即 text1[i - 1] 与 text2[j - 1] 相同和不相同两种情况
      if (text1[i - 1] === text2[j - 1]) {
        // text1[i - 1] 与 text2[j - 1] 相同时，表示此时找到了相同字符，可以让最长公共子序列 + 1
        // 即 arr[i][j] = arr[i - 1][j - 1] + 1
        arr[i][j] = arr[i - 1][j - 1] + 1;
      } else {
        // text1[i - 1] 与 text2[j - 1] 不相同，表示此时的字符不相同，当前值应取 arr[i][j - 1] 和 arr[i - 1][j]两者之间的最大值
        // 即 arr[i][j] = max( arr[i][j - 1] , arr[i - 1][j] )
        arr[i][j] = Math.max(arr[i][j - 1], arr[i - 1][j]);
      }
    }
  }
  // 最终 arr[i][j] 表示的就是最长公共子序列，因为arr多了一个初始元素arr[0][0]，所以最后一个元素是length,不是length - 1
  return arr[text1.length][text2.length];
};
```

## 背包问题通解

背包问题存在通用公式解：

1. 组合问题公式：dp[i] += dp[i-num]
2. True、False问题公式：dp[i] = dp[i] | dp[i-num]
3. 最大最小问题公式：dp[i] = min(dp[i], dp[i-num]+1)或者dp[i] = max(dp[i], dp[i-num]+1)

对于0-1背包，即元素不能重复使用，nums放在外循环，target在内循环，且内循环倒序：

```javascript
for (let i = 1; i < nums.length; i++) {
  for (let j = target; j >= nums[i]; j--) {

  }
}
```

对于完全背包，及元素能重复使用，nums放在外循环，target在内循环。且内循环正序：

```javascript
for (let i = 1; i < nums.length; i++) {
  for (let j = nums[i]; j < traget + 1 ; j++) {

  }
}
```

对于组合问题，需要考虑元素的顺序，需将target放在外循环，将nums放在内循环。

```javascript
for (let i = 1; i < target + 1; i++) {
  for (let j = 0; j < nums ; j++) {

  }
}
```

## 第416题

[分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/description/)

```javascript
var canPartition = function (nums) {
  // 数组长度 < 2 时不能被划分，直接返回false
  if (nums.length < 2) {
    return false;
  }
  let max = 0;
  // 数组的和为奇数，一半会出现小数，所有项都是正整数，加不出小数，表示数组不能被划分，返回false
  let sums = nums.reduce((a, b) => {
    max = Math.max(max, b);
    return a + b;
  });
  if (sums & 1) {
    return false;
  }
  // 最大的元素都大于数组和的一半时，表示除了最大元素之外，剩下的元素和会小于数组和的一半，所以无法凑到刚好一半，返回false
  let half = sums / 2;
  if (max > half) {
    return false;
  }
  // 创建二维数组，包含n行和half + 1列，初始值从 arr[0][0]开始，则横向最后一个值就是half。
  // 纵向表示当前选取的正整数的数量，f( arr[i][j] ) 表示 从nums的[0, i]范围内，选择若干个元素，是否存在一种方案使得和为j
  // 当j = 0时，即和为0，表示没用选取任何数，所以 arr[i][0] 的所有元素都为 true，不选取元素的和就是0，j也为0
  // 当i = 0时，表示nums数组内只有[0, 0]的范围内的元素才能被选取，即只有nums[0]能被选取
  // 所以 f( arr[0][nums[0]] ) 一定为true，f( arr[0][j] ) 其他项为false
  const arr = new Array(nums.length)
    .fill(0)
    .map(() => new Array(half + 1).fill(false));
  // 填充初始值
  for (let i = 0; i < nums.length; i++) {
    arr[i][0] = true;
  }
  arr[0][nums[0]] = true;
  // 对于 arr[i][j] 的值，有两种情况
  // 当 j >= nums[i] 时，表示和还没有达到j或者刚好等于j，所以nums[i]这项可以选可不选，两种情况有一种为true，arr[i][j]就为true
  // 当 j < nums[i] 时，表示当前项本身已经超过了当前需要达到的和，所以nums[i]必然不能选
  for (let i = 1; i < nums.length; i++) {
    for (let j = 1; j < half + 1; j++) {
      if (j >= nums[i]) {
        // 选取当前值时，arr[i][j] 的结果会与 arr[i - 1][j - nums[i]]相同
        // 即选不选nums[i]项的差别就在于两个j相差了一个nums[i]
        arr[i][j] = arr[i - 1][j] | arr[i - 1][j - nums[i]];
      } else {
        // 当前项无法被选取，所以arr[i][j]的值与arr[i - 1][j]相同
        arr[i][j] = arr[i - 1][j];
      }
    }
  }
  // 返回二维数组的最后一项，表示 [0, nums.length - 1]之前若干个数字的和正好等于half 是true还是false
  return arr[nums.length - 1][half]
};

// 优化
var canPartition2 = function (nums) {
  if (nums.length < 2) {
    return false;
  }
  let max = 0;
  let sums = nums.reduce((a, b) => {
    max = Math.max(max, b);
    return a + b;
  });
  if (sums & 1) {
    return false;
  }
  let half = sums / 2;
  if (max > half) {
    return false;
  }
  // 因为 arr[i] 的值只与 arr[i - 1] 的值有关
  // 可以使用一维数组，对数组进行原地遍历，倒序遍历，逐个覆盖当前行。
  // 因为 arr[i] 依赖 arr[i - 1] ，所以需要倒序遍历，正序遍历会修改掉 arr[i - 1]
  const arr = new Array(half + 1).fill(false);
  // 填充初始值
  arr[nums[0]] = true;
  for (let i = 1; i < nums.length; i++) {
    // 倒叙遍历，只要遍历到nums[i]就可以了，因为只需要知道 j - nums[i] 的值 nums[i] 之前的值没有必要了
    for (let j = half; j >= nums[i]; j--) {
      arr[j] = arr[j] | arr[j - nums[i]];
    }
  }

  return arr[half];
};
```

## 第322题

[零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```javascript
var coinChange = function (coins, amount) {
  if (amount === 0) {
    return 0;
  }
  // 定义数组 arr 用来储存组成数组下标值的amount时最少需要多少硬币
  // amount最大值为10000，用10001填充数组
  const arr = new Array(amount + 1).fill(10001);
  // 初始值为0，即组成0元需要0个硬币
  arr[0] = 0;
  // 遍历需要组成的amount值
  for (let i = 1; i <= amount; i++) {
    for (let j = 0; j < coins.length; j++) {
      // 只有当前硬币的值小于等于需要组成的amount值时，才能决定当前硬币是否使用
      if (coins[j] <= i) {
        // 在使用和不使用当前硬币之间取使用总硬币数最小的值
        arr[i] = Math.min(arr[i], arr[i - coins[j]] + 1);

      }
    }
  }
  // 如果最后一项没有被修改，说明没有找到能够组成对应amount的组合
  return arr[amount] === 10001 ? -1 : arr[amount];
};
```

## 第139题

[单词拆分](https://leetcode-cn.com/problems/word-break/)

```javascript
var wordBreak = function (s, wordDict) {
  // 定义字典表储存需要被拆分成的字符串，方便查询
  const wordDictSet = new Set(wordDict);
  // 定义数组储存数组下标项长度的s子字符串能否被拆分成若干个字典中出现的单词
  // 即 arr[i] 表示 s[0, i - 1] 字符串是否能够被拆分成若干个字典中出现的单词
  const arr = new Array(s.length + 1).fill(false);
  // 初始的空子字符串为true
  arr[0] = true
  for (let i = 1; i <= s.length; i++) {
    for (let j = 0; j < i; j++) {
      // 当前s[0, j]能够被拆分时，且剩下的部分也能被拆分成字典中出现的单词，表示当前s[0, i - 1]也能被拆分
      if(arr[j] && wordDictSet.has(s.substr(j, i - j))){
        // 以 j 为断点 的两个部分都能被拆分，则整体也能被拆分
        arr[i] = true
        break;
      }
    }
  }
  // 最后一项表示的就是 s[0, s.length - 1] 即整个 s 字符串能否被拆分
  return arr[s.length]
};
```

## 第474题

[一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

```javascript
var findMaxForm = function (strs, m, n) {
  // 判断当前字符串有多少个 0 和 1
  function change(str) {
    const arrStr = [];
    let zero = 0;
    for (let i = 0; i < str.length; i++) {
      if (str[i] === "0") {
        zero++;
      }
    }
    arrStr.push(zero, str.length - zero);
    return arrStr;
  }
  // 定义二维数组，arr[i, j] 表示使用 i 个 0 和 j 个 1 的时候，最多能拼出多少个字符串
  // 填充数组基础值，将所有项的初始值都填充为0，后续会取最大值来替代
  const arr = new Array(m + 1);
  for (let i = 0; i < arr.length; i++) {
    arr[i] = new Array(n + 1).fill(0);
  }
  // 遍历所有字符串
  for (let k = 0; k < strs.length; k++) {
    // 获取当前字符串中0和1的数量
    const arrStr = change(strs[k]);
    // 从大到小遍历 m 和 n ，且只能遍历到 和当前字符串中 0 和 1 数量相等，因为小于的话就无法组成当前的字符串
    for (let i = m; i >= arrStr[0]; i--) {
      for (let j = n; j >= arrStr[1]; j--) {
        // arr[i - arrStr[0]][j - arrStr[1]] 表示不拼接当前字符串时，总共能拼接成的数量 
        // + 1 表示拼接成 当前字符串 ，然后和 当前值取最大值，原地更新当前值
        arr[i][j] = Math.max(arr[i][j], arr[i - arrStr[0]][j - arrStr[1]] + 1);
      }
    }
  }
  return arr[m][n];
};
```

## 第494题

[目标和](https://leetcode-cn.com/problems/target-sum/)

```javascript
var findTargetSumWays = function (nums, S) {
  // 将数组中的数字分成两个部分，其中 P 部分为全部取正号的数字， N 部分为全部取负号的数字
  // 这两部分的和分别为 sum(P) , sum(N) ，sum(N)只是全部取负号的数字的和，还是正整数，没有变成负数
  // 可以得出 sum(P) - sum(N) = S
  // 又因为 这两部分的和为整个数组的和 即 sum(P) + sum(N) = sum(nums)
  // 两个公式相加，约去 sum(N) 可以得 2 * sum(P) = sum(nums) + S
  // 即 sum(P) = (sum(nums) + S) / 2
  // 因此，题目就变成了 只需要找到 数组的一个子集 ，让这个数组中的所有数都取正号，当他们的和 等于  (sum(nums) + S) / 2 时
  // 表示解存在，再利用动态规划方程去求解

  // 求整个数组的和
  const sum = nums.reduce((a, b) => a + b);
  // 当和比目标S还要小 或者 (sum(nums) + S) 为奇数时，表示不存在解
  // 因为 sum(P) 是正整数的和，所以 (sum(nums) + S) / 2 也一定是正整数
  if (sum < S || (sum + S) & (1 === 1)) {
    return 0;
  }

  // 求 sum(P)
  const p = (sum + S) / 2
  // 定义数组 arr[i] 表示 使用nums[0, i]的元素组成 j 的方案数量
  const arr = new Array(p + 1).fill(0);
  // 并填充初始值
  arr[0] = 1;
  // 每次遍历数组可以使用的元素 + 1
  for (let i = 0; i < nums.length; i++) {
    for (let j = p; j >= nums[i]; j--) {
      // 使用一维数组，逐行替换，arr[j] 的值分两种情况，一种使用当前nums[i]项，一种不使用
      // arr[j]即为使用当前项，arr[j - nums[i]]为不使用当前项
      arr[j] = arr[j] + arr[j - nums[i]];
    }
  }
  return arr[p];
};
```

## 第518题

[零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/description/)

```javascript
var change = function (amount, coins) {
  // 当目标总价大于0时，如果硬币数为0，则不可能凑成
  const arr = new Array(amount + 1).fill(0);
  // 当目标总价为0时，只有当所有硬币都不用的时候才能凑成，所以只有1种情况能凑成
  arr[0] = 1;
  // 遍历每个硬币
  for (let i = 0; i < coins.length; i++) {
    for (let j = coins[i]; j < amount + 1; ++j) {
      // 使用当前硬币和不使用当前硬币两种情况
      arr[j] = arr[j] + arr[j - coins[i]];
    }
  }
  return arr[amount];
};
```

## 第377题

[组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/description/)

```javascript
var combinationSum4 = function (nums, target) {
  const arr = new Array(target + 1).fill(0);
  arr[0] = 1;

  for (let i = 1; i < target + 1; i++) {
    for (let j = 0; j < nums.length; j++) {
      if (i >= nums[j]) {
        arr[i] = arr[i] + arr[i - nums[j]];
      }
    }
  }
  return arr[target];
};
```
